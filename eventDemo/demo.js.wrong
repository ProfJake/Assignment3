var events = require("events");
var readline = require("readline");
//demo.js
//A simple program to demonstrate the difference between
//how event-driven asynchronous NodeJS programs and those
//that you may be used to see.  It's important to understand
//what "event-driven" means.  Mostly, it means that the program's
//core logic is moved forward through the occurrence of known
//events.  This makes sense when you remember NodeJs is a "backend"
//runtime environment for applications.  Code (other than initialization)
//is run only when stuff happens.  


var rl = readline.createInterface({
    input: process.stdin,//use std in as this reader's input/readable stream
    output: process.stdout // std out as the reader's output/writable stream
});


console.log("What is the answer to the first question?");

//The problem here is that this code will ONLY run when data  is
//entered into stdin (typing stuff and hitting enter).  So the callback
//here has not been added to event queue and won't be until stdin
//receives stuff
var buf = new Buffer.alloc(256);
var count = 0;
process.stdin.setEncoding('utf8');
//this is a non-blocking event (asynchronous)
//"whenever data is entered into stdin, run this code"
process.stdin.on('data', (chunk) =>{
//    console.log(answer.toString());
    //this will subsequently run on every char (every new piece of data,
    //until data runs out, which stdin technically never does)

    
});


//The second question prints immediately after the first without the
//command line "waiting" for data. Because nothing has been entered
//And we used an asynchronous event handler, we've given it no reason
//to wait

/*
rl.question("What is the answer to the second question?", answer=>{
    //Opposed to the event handler above, questions are like "one-off"
    //event handlers.  They print the question and run the callback on the
    //response.  These can be chained together (see activityTracker.js)
    //designed to work in a manner similar to recursion.  
    console.log(`The second answer!  ${answer}`);

    //note that question will "block" and wait for a response from the user
    //this is more like what you are used to.
    
}); */

//We will almost always use question to query the user on commandline
//because its necessary to block and wait for the human.  But in a real
//node application, the majority of the code will be non-blocking, async
//code so that user actions in one area don't slow down other actions
